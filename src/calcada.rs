use thiserror::Error;

use crate::tiling;
use crate::mosaic;
use crate::wmach;

use std::str::FromStr;
use crate::compiler::Backend;
use crate::mosaic::MosaicError;
use crate::wmach::WmachErr;

// XXX make model either part of mosaic (still not convinced) or a standalone file that has a
// mosaic and keeps track of each step and behaves essentially like the code below expects

pub struct DapperTile {
    // XXX this should embed the coloring! We could have this be randomly generated by mosaic
    pub coord: (i32, i32),
    pub tile: tiling::Tile,
}
pub struct TileView<'a> {
    row_start: i32,
    row_end: i32,

    col_start: i32,
    col_end: i32,

    x: i32,
    y: i32,

    model: &'a Calcada,
}
impl<'a> Iterator for TileView<'a> {
    type Item = DapperTile;

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            let coord = (self.x, self.y);

            // Check to see if we're outside the bounds. If that's the case, there are no more tiles
            // remaining in the iterator.
            if self.y > self.col_end {
                return None;
            }

            // Calculate the next tile's coordinate, ensuring we wrap to the next row if we are at the
            // end. We'll check on the next iteration if the computed coordinate is valid. We know that
            // the CURRENT coordinate must be ok and that's what the caller is asking for.
            self.x = self.x + 1;
            if self.x > self.row_end {
                self.x = self.row_start;

                self.y = self.y + 1;
            }

            // If the coordinate does not correspond with a tile (e.g., it is past the border and
            // somewhere in the void), then we'll try the next coordinate; no biggie.
            if let Some(tile) = self.model.get_tile(coord.0, coord.1) {
                return Some(DapperTile {
                    coord: coord,
                    tile: tile,
                });
            }
        }
    }
}

// This is a private/opaque type that serves to ensure the caller must go through our interface.
pub struct ComputeCertificate {
    row_start: i32,
    row_end: i32,

    col_start: i32,
    col_end: i32,
}

pub struct Calcada {
    data: usize,
}
impl<'a> Calcada {
    pub fn new() -> anyhow::Result<Self> {
        let raw_bytes = std::include_bytes!("wasm.wm");
        let program = String::from_utf8_lossy(raw_bytes);
        let mosaic = wmach::Program::from_str(&program)?
            .compile()?;
        Ok(Self {
            data: 0,
        })
    }

    // this should fail if we don't have the tile computed
    pub fn get_tile(&self, row: i32, col: i32) -> Option<tiling::Tile> {
        if row > col || row < -col {
            return None;
        }

        // we don't want negative numbers with modulo
        let row = (row as u32) % 2;
        let col = (col as u32) % 2;

        // bullshit data that will always be valid
        let tile = tiling::Tile {
            north: (col % 2) as usize,
            east: (2 + (row % 2)) as usize,
            south: ((col + 1) % 2) as usize,
            west: (2 + (row + 1) % 2) as usize,
        };
        //log!("pips (nesw): {}, {}, {}, {}", tile.north, tile.east, tile.south, tile.west);
        Some(tile)
    }

    // XXX TODO this should return an opaque type that is all that tile_range() accepts
    pub fn compute(&mut self, row_start: i32, row_end: i32, col_start: i32, col_end: i32) -> Option<ComputeCertificate> {
        // calculate new tiles, if necessary

        Some(ComputeCertificate {
            row_start: row_start,
            row_end: row_end,
            col_start: col_start,
            col_end: col_end,
        })
    }

    pub fn tile_range(&'a self, proof: ComputeCertificate) -> TileView<'a> {
        // assert that compute() was called before. We seemingly have to split this up due to
        // mutable borrows being required to store the computation not mixing well with immutable
        // borrows into the tiles :(

        TileView {
            row_start: proof.row_start,
            row_end: proof.row_end,

            col_start: proof.col_start,
            col_end: proof.col_end,

            x: proof.row_start,
            y: proof.col_start,

            model: self,
        }
    }
}

